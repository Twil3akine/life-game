<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Game of Life (50x50 Canvas)</title>
    <style>
        body { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: sans-serif; 
            background: #222; 
            color: #fff; 
            margin: 0;
            padding: 20px;
        }
        h1 { margin: 10px 0; font-size: 1.5rem; }
        .controls { margin-bottom: 15px; display: flex; gap: 10px; align-items: center;}
        button { 
            padding: 8px 16px; 
            font-size: 0.9rem; 
            cursor: pointer; 
            background: #444; 
            color: #fff; 
            border: 1px solid #666; 
            border-radius: 4px; 
        }
        button:hover { background: #555; }
        canvas { 
            border: 1px solid #555; 
            background: #000; 
            cursor: crosshair;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .info { margin-top: 5px; font-size: 0.8rem; color: #888; }
    </style>
</head>
<body>
    <h1>ライフゲーム (50x50 High Speed)</h1>
    <div class="controls">
        <button id="btn-toggle">Start</button>
        <button id="btn-step">Step</button>
        <button id="btn-random">Random</button>
        <button id="btn-clear">Clear</button>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div class="info">Click/Drag to draw cells</div>

    <script>
        const ROWS = 50;
        const COLS = 50;
        const CELL_SIZE = 12;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let grid = createGrid();
        let animationId = null;
        let isRunning = false;
        let isDrawing = false;
        
        // 色相（Rainbow用）
        let hue = 0;

        function createGrid() {
            return new Array(ROWS).fill(null).map(() => new Array(COLS).fill(0));
        }

        function draw() {
            // 【変更点1】画面を真っ黒でクリアするのではなく、
            // 「半透明の黒」で塗りつぶす。これで過去の描画が薄く残り、残像になる。
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; // 0.15が残像の強さ
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 生きているセルを描画
            // 【変更点2】色を固定の緑ではなく、変化するHslカラーにする
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.shadowBlur = 15; // 【変更点3】光っているように見せる（重ければ削除）
            ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x]) {
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                    }
                }
            }
            
            // 描画ごとに色相を回す
            hue = (hue + 0.5) % 360;
        }

        function computeNextGen() {
            const nextGrid = grid.map(arr => [...arr]);
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const ny = y + dy;
                            const nx = x + dx;
                            // ループする世界にする（端っこが反対側に繋がる）
                            // これも「おもろい」ポイントの一つ
                            const wy = (ny + ROWS) % ROWS;
                            const wx = (nx + COLS) % COLS;
                            neighbors += grid[wy][wx];
                        }
                    }
                    const cell = grid[y][x];
                    if (cell === 1 && (neighbors < 2 || neighbors > 3)) nextGrid[y][x] = 0;
                    else if (cell === 0 && neighbors === 3) nextGrid[y][x] = 1;
                }
            }
            grid = nextGrid;
        }

        function loop() {
            if (isRunning) {
                computeNextGen();
            }
            draw(); // 停止中も残像処理を描画し続けるとかっこいいので常時呼ぶ
            animationId = setTimeout(() => requestAnimationFrame(loop), 30); 
        }

        // --- 以下イベントハンドラは同じ ---
        const btnToggle = document.getElementById('btn-toggle');
        btnToggle.addEventListener('click', () => {
            if (isRunning) {
                isRunning = false;
                btnToggle.textContent = 'Start';
            } else {
                isRunning = true;
                btnToggle.textContent = 'Stop';
            }
        });

        document.getElementById('btn-step').addEventListener('click', () => {
            computeNextGen();
            // drawはloopで常に回っているのでここでは呼ばなくてOK
        });

        document.getElementById('btn-random').addEventListener('click', () => {
            grid = grid.map(row => row.map(() => Math.random() > 0.8 ? 1 : 0));
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            grid = createGrid();
            // 画面を一度真っ黒に戻す
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });

        // マウス操作
        function getCellFromMouseEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
            return { x, y };
        }
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const { x, y } = getCellFromMouseEvent(e);
            if (x>=0 && x<COLS && y>=0 && y<ROWS) grid[y][x] = grid[y][x] ? 0 : 1;
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const { x, y } = getCellFromMouseEvent(e);
            if (x>=0 && x<COLS && y>=0 && y<ROWS) grid[y][x] = 1;
        });
        window.addEventListener('mouseup', () => isDrawing = false);

        // ループ開始
        loop();    </script>
</body>
</html>
